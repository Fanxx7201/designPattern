# 计算机基础
<br>

## 目录

### 计算机组成原理- 概述
* [计算机发展历史](#计算机发展历史)
* [计算机的分类](#计算机的分类)
* [计算机的体系与结构](#计算机的体系与结构)
* [计算机的层次与编程语言](#计算机的层次与编程语言)
* [计算机的速度单位](#计算机的速度单位)
* [计算机的字符与编码集](#计算机的字符与编码集)
### 计算机组成原理- 组成
* [计算机的字符与编码集](#计算机的字符与编码集)
* [计算机的总线](#计算机的总线)
* [计算机的输入输出设备](#计算机的输入输出设备)
* [计算机的存储器概览](#计算机的存储器概览)
* [计算机的主存储器与辅助存储器](#计算机的主存储器与辅助存储器)
* [计算机的高速缓存](#计算机的高速缓存)
* [计算机的指令系统](#计算机的指令系统)
* [计算机的控制器](#计算机的控制器)
* [计算机的运算器](#计算机的运算器)
* [计算机指令执行过程](#计算机指令执行过程)
### 计算机组成原理- 计算篇

### 操作系统之基础篇
* [操作系统概览](#操作系统概览)
* [进程管理之进程实体](#进程管理之进程实体)
* [进程管理之五状态模型](#进程管理之五状态模型)
* [进程管理之进程同步](#进程管理之进程同步)
* [Linux的进程管理](#Linux的进程管理)


## 计算机组成原理- 概述
### 计算机的发展历史
* 计算机发展的四个阶段
> 第一阶段: 电子管计算机 最著名的:埃尼阿克  
> 第二阶段: 晶体管计算机  
> 第三阶段: 集成电路计算机  
> 第四阶段: 超大规模集成电路计算机  
* 微型计算机的发展历史
> 单核CPU  
> 多核CPU
### 计算机的分类
* 超级计算机
> 功能最强、运算能力最快、存储容量最大的计算机, 多用于国家高科技领域和尖端技术研究  
> 标记他们运算速度的单位是TFlop/s : 每秒一万亿次浮点计算  
* 大型计算机(去"IOE", 将大型计算机转向为服务器)
* 迷你计算机(服务器)
> 称为服务器, 不需要特殊的空调场所, 具备不错的算力, 可以完成较复杂的运算.  
* 工作站
> 高端的通用微型计算机, 提供比个人计算机更强大的性能  
* 微型计算机
> 又称为个人计算机.  
### 计算机的体系与结构
#### 冯诺依曼体系
> 将程序指令和数据一起存储的计算机设计概念结构  
* 组件: 
> ①必须有一个存储器: 存储运行的程序,存储运行所需要的数据  
> ②必须有一个控制器: 控制程序的扭转  
> ③必须有一个运算器: 负责完成运算的操作  
> ④必须有输入设备  
> ⑤必须有输出设备  
* 功能:
> 能够把需要的程序和数据送至计算机中   
> 能够长期记忆、数据、中间结果及最终运算结果的能力(存储器)  
> 能够具备算数、逻辑运算和数据传送等数据加工处理的能力(运算器)   
> 能够按照要求将处理结果输出给用户  
* CPU = 运算器 + 控制器
* 冯诺依曼瓶颈: CPU和存储器速率之间的问题无法调和, CPU的处理速度快, 而CPU到存储设备的传输速度慢, CPU经常空转等待数据的传输

#### 现代计算机的结构
* CPU = 运算器 + 控制器 + 存储器. CPU是以存储器为核心
### 计算机的层次与编程语言
#### 程序翻译与程序解释
* 人类语言和计算机语言是不相通的, 需要将人类语言翻译成计算机语言.
* 程序翻译: 高级的计算机语言L1, 生成低级的计算机语言L0后, 计算机执行低级的计算机语言. (编译器进行翻译)
* 程序解释: 为了实现高级的计算机语言L1, 使用L0实现另一个程序, L1作为输入进行执行, 每一个L1的语句, 都会在L0里做等价转换.(解释器实现另一个程序)
* 程序翻译与程序解释的异同
1. 计算机执行的指令都是L0
2. 翻译过程生成新的L0程序, 解析过程不生成新的L0程序
3. 解释过程由L0编写的解释器去解释L1程序
* JAVA是[翻译 + 解释]型的语言. java程序通过编译生成JVM字节码文件, 然后解释器解析为机器码进行执行.
#### 计算机的层次与编程语言
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.png)

* 微指令 < 微程序 = 机器指令
1. 一条机器指令对应一个微程序
2. 一个微程序对应一组微指令
### 计算机的速度单位
#### 容量单位
* 在物理层面上, 只认识高低电平. 高电平表示1, 低电平表示0. 0和1表示的是比特位(bit).
* 字节: 1Byte = 8bits
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%AE%B9%E9%87%8F%E5%8D%95%E4%BD%8D.png)
* 为什么500G硬盘格式化后, 为465G? 硬盘商一般用10进位标记容量.
#### 速度单位
* 网络速度
1. 为什么电信100M光纤, 测试峰值速度只有12M每秒? 100M/s = 100Mbps = 100Mbit/s, 这里算的是比特位. 需要除以8转为字节, 100Mbit/s = (100/8)MB/s = 12.5MB/s
* CPU速度
1. CPU的速度一般体现为CPU的时钟频率, CPU的时钟频率的单位一般为赫兹(Hz), 主流的CPU时钟频率在2GHz以上
2. 赫兹: 秒分之一. 每秒中的周期性变动重复次数的计量. 它并不是描述计算机领域专用的.
3. 2GHz = 2 * 1000 ^ 3  Hz = 每秒20亿次. 也就是每秒从0变为1的频次有20亿次.
### 计算机的字符与编码集
#### 字符编码集的历史
* ASCII码
1. 7个bit可以完全表示ASCII码, 包含95个可打印字符, 33个不可打印字符(包括控制字符), 也就是2^7个字符.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/ASCII%E7%A0%81%E8%A1%A8.png)
* Extended ASCII 码
1. 从7个bits拓展到8个
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/Extended%20ASCII%20%E7%A0%81.png)
* 字符编码集的国际化
1. 欧洲, 中亚等国家语言多样, 语言体系不一样, 很多国家不是有限字符组合的语言.
#### 中文编码集
1. GB2312 
2. GBK <汉字内码拓展规范> 收录21003个汉字
3. Unicode: 兼容全球的字符集. 统一码, 万国码, 单一码. 定义了世界通用的符号集, UTF-8, UTF-16等实现了编码. UTF-8是以字节为单位对Unicode进行编码
4. 编程: UTF-8编码. WINDOWS: 系统默认GBK

## 计算机组成原理- 组成
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AB%A0%E6%A6%82%E8%A7%88.png)
### 计算机的总线
#### 总线的概述
* USB = Universal Serial Bus 通用串行总线
1. 提供了对外连接的接口
2. 不同设备通过USB接口进行连接
3. 连接的标准, 促使外围设备接口的统一
* PCI总线
* ISA总线等
#### 总线的分类
* 片内总线: 芯片内部总线, 连接寄存器和寄存器之间, 也可以连接寄存器与控制器、运算器之间. --> 高集成度芯片内部的信息传输线
* 系统总线: 连接系统内外部的总线. 系统总线包括以下几部分
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF.png)
1. 数据总线
> 总线位数一般和CPU位数相同(32位、64位), 总线的位数是数据总线的重要参数
> 双向传输各个部件的数据信息
2. 地址总线
> 指定源数据或者目的数据在内存中的地址
> 地址总线的位数与存储单元有关
3. 控制总线
> 用来发出各种控制信号的传输线
> 控制信号经由控制总线从一个组件发送给另一个组件
> 控制总线可以监视不同组件之间的状态(就绪/未就绪)
#### 总线的仲裁
* 为什么需要总线仲裁? 假设主存要和IO设备交换数据, 硬盘和IO设备都就绪了, 那么谁先使用总线呢? 就需要仲裁器的仲裁.(解决总线使用权冲突的问题)
* 总线仲裁的方法? 
1. 链式查询
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png)
> 好处是电路复杂度低, 仲裁方式简单
> 坏处是优先级低的设备难以获得总线使用权, 对电路故障敏感
2. 计时器定时查询: 仲裁控制器对设备编号, 使用计数器累计计数. 接收到仲裁信号后, 往所有设备发出计数值. 计数值与设备编号一致则获得总线使用权.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png)
3. 独立请求: 每个设备均有总线独立连接仲裁器. 设备可以独立向仲裁器发送请求, 接收请求. 当同时收到多个请求信号, 仲裁器有权按优先级分配使用权.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.png)
> 好处: 响应速度快, 优先顺序可以动态改变
> 坏处: 设备连线多, 总线控制复杂

### 计算机的输入输出设备
#### 常见的输入输出设备

#### 输入输出接口的通用设计
* 数据线: I/O设备与主机进行数据交换. 分为单向传输和双向传输

* 状态线: I/O设备状态向主机报告的信号线, 查询设备是否已经正常连接并就绪, 可以查询设备是否已经被占用

* 命令线: CPU向设备发送命令的信号线(CPU读取磁盘某个区域的数据), 可以发送读写信号和启动停止信号(主机发送信号, 让光驱启动或者停止).

* 设备选择线: 主机选择I/O设备进行操作的信号线, 对连在总线上的设备进行选择(USB总线连接了3个u盘, 通过设备选择线进行选择要连接的u盘).

#### CPU与IO设备的通信
* 前提: CPU的速度和IO设备的速度不一致, CPU速度可能是IO设备的十倍百倍.

* 程序中断方法: IO设备就绪时, 给CPU发送中断信号, CPU有专门的电路响应中断信号.
> 某一个时刻, CPU发送信号, 启动打印机, 打印机准备完成时, 向CPU发送中断信号, CPU响应信号(可能延时), 这时CPU发送数据.  
> 缺点是频繁地打断CPU  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD.png)
* DMA(直接存储器访问): DMA直接连接主存与IO设备, DMA工作时不需要CPU的参与. 硬盘和显卡都有DMA设备
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/DMA.png)

### 计算机的存储器概率
####存储器的分类
* 按介质分类
1. 半导体存储器: 内存, u盘, 固态硬盘
2. 磁存储器: 磁带, 磁盘
* 按照存取方式
1. 随机存储器(RAM), 可以随机读取, 和位置无关
2. 串行存储器: 与位置有关, 按顺序查找
3. 只读存储器(ROM), 只读不写.
####存储器的层次结构
* 读写速度: 5400转, 7200转
* 存储容量: 2t, 4g
* 价格
* 容量 + 价格 => 位价: 每比特位价格
----
* 存储器的层次结构
1. 缓存:速度快, 位价高
2. 主存: 速度适中, 位价适中
3. 辅存: 速度慢, 位价低  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)
* 缓存-主存层次: 是利用了局部性原理. 实现: 在CPU和主存之间增加了一层速度快(容量小)的cache, 目的是解决主存[速度]不足的问题   
> 什么是局部性原理? 局部性原理是CPU访问存储器时, 无论是存取指令还是存取数据, 所访问的存储单元都趋于聚集在一个较小的连续区域中.  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86.png)
* 主存-辅存层次: 是利用局部性原理. 实现: 主存之外增加辅助存储器(磁盘, SD卡, U盘等), 目的是解决主存[容量]不足问题.
### 计算机的主存储器与辅助存储器
#### 主存储器 - 内存
* RAM(随机存取存储器), 通过电容来存储数据, 必须隔一段时间刷新一次, 断电的话一段时间后将丢失所有数据.   
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8-%E5%86%85%E5%AD%98.png)
* 32位系统, 支持2^32 = 4GB内存. 64位系统, 支持2 ^ 64 = 2 ^34 GB  
#### 辅助存储器 - 磁盘
* 算法
1. 先来先服务算法
2. 最短寻道时间算法
3. 扫描算法
4. 循环扫描算法
### 计算机的高速缓存
#### 高速缓存的工作原理
* 内存中的两个概念
1. 字: 存放在一个存储单元中的二进制代码组合.可以表示一个数据, 一个指令或者是一个字符串, 是最小的单位  
2. 字块: 存储在连续的存储单元中被看做是一个单元的一组字.  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%AD%97%E4%B8%8E%E5%AD%97%E5%9D%97%E7%9A%84%E8%BF%90%E7%AE%97.png)
> 字的地址包含两个部分, 前m位指定字块地址, 后b位指定字在字块中的地址  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%AD%97%E7%9A%84%E8%AE%A1%E7%AE%97.png)

* 缓存和主存的关系
1. 存储的逻辑结构相似
2. 缓存容量小
3. 缓存速度快
* CPU与缓存, 主存的关系
1. CPU需要的数据在缓存中, 会去缓存中去拿
2. 不在的话去主存中拿
* 高速缓存的工作原理  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png)
* 计算得知, 为了提高CPU执行效率, 需要将缓存中的数据替换为CPU需要的数据
#### 高速缓存的替换策略
* 替换时机: 缓存中没有数据时, 就需要从主存中载入所需的数据.
* 替换策略
1. 随机算法
2. 先进先出算法(FIFO)
> 将缓存看做一个先进先出的队列, 优先替换掉最先进去队列的字块  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95.png)
3. 最不经常使用算法(LFU)
> 优先淘汰最不经常使用的字块, 这需要额外的空间记录字块的使用频率
4. 最近最少使用算法(LRU)
> 优先淘汰一段时间内没有使用的字块, 有多种实现方法, 一般使用双向链表. 把当前访问的节点置于链表前面, 保证链表的头节点是最近使用的. 淘汰尾部.
### 计算机的指令系统
#### 机器指令的形式
* 由两部分组成: 操作码, 地址码
> 操作码: 指明指令要完成的操作, 操作码的位数反映了机器的操作种类, 如果有8位操作码, 那就有2 ^ 8 = 256种操作.  
> 地址码: 直接给出操作数或者是操作数的地址, 分三地址指令, 二地址指令, 和一地址指令  
1. 三地址指令, 有三个地址, 操作码OP, 如果是加法操作的话, 就是地址1 + 地址2 = 地址3   
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png)
2. 二地址指令  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png)
3. 一地址指令一种是对自己操作, 另外一种比如说是自增操作, 不需要其他地址参与的  
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png)
4. 零地址指令: 机器指令中无地址码, 空操作, 停机操作, 中断返回操作等等.    
#### 机器指令的操作类型
* 数据传输
1. 寄存器之间, 寄存器与存储单元, 存储单元之间传送
2. 数据读写, 交换地址数据, 清零置1等操作
* 算数逻辑操作类型
1. 操作数之间的加减乘除运算
2. 操作数的与或非等逻辑位运算
* 移位操作
1. 数据左移 -> 相当于乘以2,  数据右移 -> 相当于除以2
2. 移位操作是完成数据在算术逻辑单元的必要操作
* 控制指令
1. 等待指令, 停机指令, 空操作指令, 中断指令等
#### 机器指令的寻址方式
* 指令寻址
1. 顺序寻址: 按照地址顺序, 执行指令
2. 跳跃寻址: 指令中有某个指令是jump, 就跳跃回指定的指令了
* 数据寻址
1. 立即寻址 : 指令直接获得操作数, 无需访问存储器
2. 直接寻址 : 直接给出操作数在主存中的地址, 寻找操作数简单
3. 间接寻址 : 指令地址码给出的是操作数地址的地址, 需要访问一次或者多次主存来获取操作数
### 计算机的控制器
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E6%8E%A7%E5%88%B6%E5%99%A8.png)
#### 程序计数器
* 存储下一条指令的地址, 循环从程序计数器中拿出指令. 指令拿出来的时候, 指向下一条指令
#### 时序发生器
* 电气工程领域, 用于发送时序脉冲. CPU依据不同的时序脉冲有节奏地进行工作. 类似一个节拍器.
#### 指令译码器
* 是控制器的主要部件, 计算机指令是由操作码和地址码组成, 指令译码器是翻译操作码对应的操作以及控制传输地址码对应的数据
#### 指令寄存器
* 控制器的主要部件之一, 从主存或者是高速缓存取计算机指令
#### 主存地址寄存器
* 保存当前CPU正要访问的内存单元的地址
#### 主存数据寄存器
* 保存当前CPU正要读或写的主存数据
#### 通用寄存器
* 用于暂时存放或者传送数据或者指令, 可以保存ALU的运算中间结果, 容量比一般专用寄存器容量大
### 计算机的运算器
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%BF%90%E7%AE%97%E5%99%A8.png)
#### 数据缓冲器
* 输入缓冲: 暂时存放外设送过来的数据
* 输出缓冲: 暂时存放送往外设的数据
#### ALU: 算术逻辑单元, 是运算器的主要组成
* 可以完成常见的位运算(左右移, 与或非等), 算术运算(加减乘除等)
#### 状态字寄存器
* 存放运算状态(条件码, 进位, 溢出, 结果正负等)
* 存放运算控制信息(调试跟踪标记位, 允许中断位等)
#### 通用寄存器
* 用于暂时存放或传送数据或者指令, 可以保存ALU的运算中间结果, 容量比一般专用寄存器要大
### 计算机指令执行过程
#### 指令执行过程
* 取指令 -> 分析指令-> 执行指令
1. 将数据和指令缓存起来, 放到CPU的高速缓存中
2. 程序计数器, 将需要执行的指令缓存起来. 总线来到指令缓存, 拿到指令的操作码和地址码
3. 总线来到指令寄存器, 缓存起来指令的内容(也就是指令的操作码和地址码)
4. 将指令发送给指令译码器和时序发生器, 指令译码器理解了指令的内容之后, 发出控制信号, 程序计数器 + 1, 来到运算器中, 进行操作.
5. 转载数据到寄存器, ALU处理数据, 记录运算状态, 送出运算结果.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

#### CPU的流水线设计
* 类似于工厂的装配线, 使得多个产品同时被加工, 同一个时刻, 不同产品位于不同的加工阶段.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/CPU%E6%B5%81%E6%B0%B4%E7%BA%BF.png)

## 计算机组成原理- 计算篇
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%20%E8%AE%A1%E7%AE%97%E7%AF%87.png)
### 进制运算的基础

## 操作系统- 基础篇
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B.png)
* 多道程序设计
> 理解: 早期的批处理系统, 一次只能一次处理一个任务. 多道程序设计, 可以一次处理多个任务.  
> 概念: 在计算机内存中存放多个程序, 多道程序在计算机的管理之下相互穿插运行, 对多道程序的管理是操作系统的重要功能.  
> 五大功能: 进程管理, 文件管理, 存储管理, 设备管理, 作业管理
### 操作系统概览
#### what & why
* 概念: 是计算机程序, 可以管理计算机硬件和软件资源
* 功能: 管理配置内存, 决定资源供需顺序, 控制输入输出设备. 提供了让用户和系统交互的操作界面
* 为什么需要操作系统? 我们不能直接操作硬件, 设备种类很多, 需要统一的界面. 操作系统的简易性, 可以使更多的人能够使用计算机.
#### 操作系统基本功能
* 统一管理计算机资源: 包括处理器资源, io设备资源, 存储器资源, 文件资源等.
* 实现了对计算机资源的抽象
1. 用户无需面向硬件接口编程
2. io设备管理软件, 提供读写接口
3. 文件管理软件, 提供操作文件接口
* 提供了用户与计算机之间的接口
1. 图像窗口形式
2. 命令形式
3. 系统调用形式
#### 操作系统相关概念
* 并发性
* 共享性: 操作系统中的资源可以供多个并发的程序共同使用
1. 多个程序可同时使用主存资源
2. 资源共享根据属性可以分为两种方式
> 互斥共享: 比如打印机, 一个程序占用了, 另一个程序想使用的话, 需要等他使用完.
> 同时访问: 某个资源一段时间并发被多个程序访问. 
* 虚拟性 : 把一个物理实体转变为若干个逻辑实体. 物理实体是真实存在的, 逻辑实体是虚拟的. 虚拟的技术主要有时分复用技术, 空分复用技术
> 时分复用技术: 资源在时间上进行复用, 不同程序并发使用. 多道程序分时使用计算机的硬件资源, 可以提高资源的利用率.  
>> 虚拟处理器技术: 借助多道程序设计技术, 为每个程序建立进程, 多个程序分时复用处理器  
>> 虚拟设备技术: 将物理设备虚拟为多个逻辑设备, 每个程序占用一个逻辑设备. 多个程序通过逻辑设备并发访问.  
> 空分复用技术: 用来虚拟磁盘, 虚拟内存等, 可以提升资源的利用率, 提高编程的效率.  
>> 虚拟磁盘: 将物理磁盘虚拟为逻辑磁盘, C, D等磁盘就是逻辑磁盘. 这样使用更加安全  
>> 虚拟内存技术: 逻辑上扩大程序的存储容量, 使用比实际内存更大的容量, 提升编程效率.
* 异步性: 多道程序环境小, 允许多个程序并发执行. 进程在使用资源时, 可能需要等待或者放弃(比如互斥资源). 进程的执行不是一气呵成, 而是走走停停的形式推进.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E5%BC%82%E6%AD%A5%E6%80%A7.png)
### 进程管理之进程实体
#### 为什么需要进程
* 没有操作系统之前, 资源属于当前运行的程序, 计算机只属于一个资源. 配置了操作系统, 引入多道程序设计的概念. 进程合理的隔离资源, 运行环境, 提升资源利用率
* 为什么需要进程?
1. 进程是系统进行资源分配和调度的基本单位
2. 进程作为程序独立运行的载体, 保障程序正常运行
3. 进程的存在使得操作系统资源的利用率大幅提升
#### 进程的实体
* 主存中的进程形态
1. 标识符: 唯一标记一个进程, 用于区别其他进程(比如进程id)
2. 状态: 标记进程的状态, 如运行态
3. 程序计数器: 进程即将被执行的下一条指令的地址
4. 内存指针: 程序代码, 进程数据相关的指针
5. 上下文数据: 进程执行时, 处理器存储的数据
6. IO状态信息: 被进程IO操作所占用的文件列表
7. 记账信息: 使用处理器时间, 时钟数总和等
等等
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%BD%A2%E6%80%81.png)
* 进程中最重要的内容: PCB (进程控制块)
1. 描述和控制进程运行的通用数据结构, 每个进程都有进程控制块.
2. 可以记录进程的状态, 控制进程运行的全部信息
3. PCB使得进程是能够独立运行的基本单位
4. PCB是操作系统进行调度经常会被读取的信息
5. PCB是常驻内存的, 存放在系统专门开辟的PCB区域内
* 进程与线程的区别
1. 一个进程可以有多个线程
2. 进程是系统进行资源分配和调度的基本单位, 线程是操作系统进行运行调度的最小单位
3. 线程包含在进程中, 是进程中实际运行工作的单位
4. 一个进程可以并发多个线程, 每个线程执行不同的任务
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.png)
### 进程管理之五状态模型
#### 就绪状态
* 进程被分配到除了CPU以外的所有需要的资源后
* 只要获得CPU的使用权, 就可以立即运行
* 所以这种其他资源都准备好, 只差CPU资源的状态为就绪状态
* 一个系统中, 多个处于就绪状态, 就绪队列.
#### 执行状态
* 进程获得CPU, 其程序正在执行, 称为执行状态
* 单处理机中, 在某个时刻只能有一个进程是处于执行状态
#### 阻塞状态
* 进程因为某种原因, 如其他设备未就绪而无法继续执行, 从而放弃CPU的状态称为阻塞状态
* 同样有阻塞队列.
#### 创建状态
* 第一步: 分配PCB, 第二步: 插入就绪队列. 创建进程时拥有PCB, 但是其他资源尚未就绪的状态称为创建状态. --> 操作系统会提供fork函数接口创建进程.
#### 终止状态
* 进程结束后, 由系统清理或者归还PCB的状态称为终止状态
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png)

### 进程管理之进程同步
#### 为什么需要进程间的同步
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png)
* 操作缓冲需要三个步骤, register = count, register = register + 1, count = register
* 程序并发执行时, 由于以上的操作不是原子性的, 会出问题.
* 解决办法: 进程间的同步: 对竞争资源在多进程间进行次序的协调. 使得并发执行的多个进程之间可以有效使用资源和相互合作.
#### 进程间同步的原则
* 临界资源的概念: 是指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源. 当有进程在使用临界资源时, 其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可以重新竞争使用共享资源.
* 同步的原则
1. 空闲让进: 资源无占用, 允许使用
2. 忙则等待: 资源被占用, 请求线程等待
3. 有限等待: 保证有限等待时间能够使用资源
4. 让权等待: 等待时, 进程需要让出CPU
* 进程同步的方法
1. 消息队列
2. 共享存储
3. 信号量
#### 线程同步
* 线程同步的方法
1. 互斥量
2. 读写锁
3. 自旋锁
4. 条件变量
### Linux的进程管理
#### Linux进程的相关概念
* 进程的类型
1. 前台进程: 具有终端 ,可以和用户交互的进程
2. 后台进程: 没有占用终端
> 优先级比前台进程低
> 以&结束, 就是在后台进行
3. 守护进程: 特殊的后台进程, 很多守护进程是系统引导时启动, 一直运行直到系统关闭.
> 进程以"d"结尾的, 一般是守护进程. crond, httpd, sshd, mysqld
* 进程的标记
1. 进程的ID, 进程的唯一标记, 每个进程拥有不同的id. [top命令查看所有进程]
2. 父子进程: 进程A调用fork函数产生进程B, B调用fork函数产生C, 那他们是父子关系. [pstree命令查看进程父子关系]
3. ID为0的进程为idle进程, 是系统创建的第一个进程
4. ID为1的进程为Init进程, 是0号的子进程, 完成系统初始化.
![Image text](https://github.com/Fanxx7201/designPattern/blob/master/src/main/resources/pics/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%87%E8%AE%B0.png)
#### 操作Linux进程的相关命令
* ps命令
> ps 打印进程
> ps -aux 打印线程详细信息
> ps -u root 查看root用户的进程
> ps -aux | grep 'java' 查看相关的进程
> ps -ef --forest 查看进程树(父子关系)
> ps -aux --sort=-pcpu 按照cpu使用排序查看进程
* top命令: 查看系统进程所有状态
> pid: 进程id
> user: 用户
> pr: 优先级
> virt: 虚拟内存
> %cpu: 占用cpu
> % mem: 内存占用
* kill命令
> kill -9 : 停掉当前线程
> kill -l : 查看操作系统支持的信号







